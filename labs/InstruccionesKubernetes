Let’s look at some basic kubectl commands.

kubectl requires configuration so that it targets the appropriate cluster. Get cluster information with the following command:

kubectl config get-clusters



A kubectl context is a group of access parameters, including a cluster, a user, and a namespace. View your current context with the following command:

kubectl config get-contexts



List all the Pods in your namespace. If this is a new session for you, you will not see any Pods.

kubectl get pods

Export your namespace as an environment variable so that it can be used in subsequent commands.
export MY_NAMESPACE=sn-labs-$USERNAME


Click the Explorer icon (it looks like a sheet of paper) on the left side of the window, and then navigate to the directory for this lab: CC201 > labs > 2_IntroKubernetes. Click on Dockerfile. This is the file that will be used to build our image.

Build and push the image again, as it may have been deleted automatically since you completed the first lab.

docker build -t us.icr.io/$MY_NAMESPACE/hello-world:1 . && docker push us.icr.io/$MY_NAMESPACE/hello-world:1



Run the hello-world image as a container in Kubernetes.

kubectl run hello-world --image us.icr.io/$MY_NAMESPACE/hello-world:1 --overrides='{"spec":{"template":{"spec":{"imagePullSecrets":[{"name":"icr"}]}}}}'

The --overrides option here enables us to specify the needed credentials to pull this image from IBM Cloud Container Registry. Note that this is an imperative command, as we told Kubernetes explicitly what to do: run hello-world.



List the Pods in your namespace.

kubectl get pods



Great, the previous command indeed created a Pod for us. You can see an auto-generated name was given to this Pod.

You can also specify the wide option for the output to get more details about the resource.

kubectl get pods -o wide


Describe the Pod to get more details about it.

kubectl describe pod hello-world



Note: The output shows the pod parameters like Namespace, Pod Name, IP address, the time when the pod started running and also the container parameters like container ID, image name & ID, running status and the memory/CPU limits.

Delete the Pod.

kubectl delete pod hello-world


This command takes a while to execute the deletion of the pod. Please wait till the terminal prompt appears again.

List the Pods to verify that none exist.

kubectl get pods













Create a Pod with imperative object configuration
Imperative object configuration lets you create objects by specifying the action to take (e.g., create, update, delete) while using a configuration file. A configuration file, hello-world-create.yaml, is provided to you in this directory.

Use the Explorer to view and edit the configuration file. Click the Explorer icon (it looks like a sheet of paper) on the left side of the window, and then navigate to the directory for this lab: CC201 > labs > 2_IntroKubernetes. Click hello-world-create.yaml to view the configuration file.


Use the Explorer to edit hello-world-create.yaml. You need to insert your namespace where it says <my_namespace>. Make sure to save the file when you’re done.


Imperatively create a Pod using the provided configuration file.
kubectl create -f hello-world-create.yaml
Note that this is indeed imperative, as you explicitly told Kubernetes to create the resources defined in the file.



List the Pods in your namespace.
kubectl get pods


Delete the Pod.
kubectl delete pod hello-world


This command takes a while to execute the deletion of the pod. Please wait till the terminal prompt appears again.

List the Pods to verify that none exist.
kubectl get pods


Previous















Create a Pod with a declarative command
The previous two ways to create a Pod were imperative – we explicitly told kubectl what to do. While the imperative commands are easy to understand and run, they are not ideal for a production environment. Let’s look at declarative commands.

A sample hello-world-apply.yaml file is provided in this directory. Use the Explorer again to open this file. Notice the following:
We are creating a Deployment (kind: Deployment).
There will be three replica Pods for this Deployment (replicas: 3).
The Pods should run the hello-world image (- image: us.icr.io/<my_namespace>/hello-world:1).


You can ignore the rest for now. We will get to a lot of those concepts in the next lab.

Use the Explorer to edit hello-world-apply.yaml. You need to insert your namespace where it says <my_namespace>. Make sure to save the file when you’re done.


Use the kubectl apply command to set this configuration as the desired state in Kubernetes.
kubectl apply -f hello-world-apply.yaml


Get the Deployments to ensure that a Deployment was created.
kubectl get deployments


List the Pods to ensure that three replicas exist.

kubectl get pods



With declarative management, we did not tell Kubernetes which actions to perform. Instead, kubectl inferred that this Deployment needed to be created. If you delete a Pod now, a new one will be created in its place to maintain three replicas.

Note one of the Pod names from the previous step, replace the pod_name in the following command with the pod name that you noted and delete that Pod and list the pods. To see one pod being terminated, there by having just 2 pods, we will follow the delete, immediately with get.

kubectl delete pod <pod_name> && kubectl get pods



This command takes a while to execute the deletion of the pod. Please wait till the terminal prompt appears again.

List the Pods to see a new one being created.
You may have to run this command a few times as it may take a while to create the new pod.


kubectl get pods

NAME                    READY   STATUS    RESTARTS   AGE
hello-world-774ddf45b5-28k7j   1/1     Running   0          36s
hello-world-774ddf45b5-9cbv2   1/1     Running   0          112s
hello-world-774ddf45b5-svpf7   1/1     Running   0          112s
Copied!
The output should reflect three pods running.














Load balancing the application
Since there are three replicas of this application deployed in the cluster, Kubernetes will load balance requests across these three instances. Let’s expose our application to the internet and see how Kubernetes load balances requests.

In order to access the application, we have to expose it to the internet using a Kubernetes Service.
kubectl expose deployment/hello-world


This command creates what is called a ClusterIP Service. This creates an IP address that accessible within the cluster.

List Services in order to see that this service was created.

kubectl get services



Open a new terminal window using Terminal > Split Terminal.


Since the cluster IP is not accessible outside of the cluster, we need to create a proxy. Note that this is not how you would make an application externally accessible in a production scenario. Run this command in the new terminal window since your environment variables need to be accessible in the original window for subsequent commands.

kubectl proxy



This command doesn’t terminate until you terminate it. Keep it running so that you can continue to access your app.

In the original terminal window, ping the application to get a response.

curl -L localhost:8001/api/v1/namespaces/sn-labs-$USERNAME/services/hello-world/proxy



Notice that this output includes the Pod name.

Run the command which runs a for loop ten times creating 10 different pods and note names for each new pod.

for i in `seq 10`; do curl -L localhost:8001/api/v1/namespaces/sn-labs-$USERNAME/services/hello-world/proxy; done



You should see more than one Pod name, and quite possibly all three Pod names, in the output. This is because Kubernetes load balances the requests across the three replicas, so each request could hit a different instance of our application.

Delete the Deployment and Service. This can be done in a single command by using slashes.

kubectl delete deployment/hello-world service/hello-world



Note: If you face any issues in typing further commands in the terminal, press Enter.

Return to the terminal window running the proxy command and kill it using Ctrl+C.









